<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bảo Tàng Lịch Sử</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #instruction-overlay {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: #fff; font-size: 13px; pointer-events: none; z-index: 5; font-weight: 700;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.8); background: rgba(0,0,0,0.5);
            padding: 15px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
        }

        #joystick-area { position: absolute; bottom: 40px; left: 40px; width: 160px; height: 160px; z-index: 20; pointer-events: auto; }
        .joy-btn {
            position: absolute; width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255,255,255,0.4);
            border-radius: 50%; cursor: pointer; display: flex;
            justify-content: center; align-items: center; font-size: 24px; font-weight: bold; color: #fff;
            backdrop-filter: blur(4px); box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        .joy-btn:active { background: #ffcc00; color: #000; border-color: #ffcc00; transform: scale(0.95); }
        #btn-up { top: 0; left: 55px; }
        #btn-down { bottom: 0; left: 55px; }
        #btn-left { top: 55px; left: 0; }
        #btn-right { top: 55px; right: 0; }

        #zoom-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; backdrop-filter: blur(10px);
        }
        #zoom-container { display: flex; flex-direction: column; align-items: center; max-width: 90%; max-height: 90%; pointer-events: auto; position: relative; }
        .zoom-content { max-width: 100%; max-height: 60vh; border: 2px solid #fff; box-shadow: 0 0 50px rgba(0,0,0,0.8); border-radius: 4px; }
        #zoom-caption {
            color: #ddd; margin-top: 20px; text-align: center; width: 100%;
            font-size: 16px; line-height: 1.6; background: rgba(30,30,30,0.9); padding: 20px; border-radius: 8px;
            max-height: 20vh; overflow-y: auto; border: 1px solid #444;
        }
        #close-modal-btn {
            margin-top: 20px; padding: 10px 30px; background: #b30000; color: white;
            border: none; font-weight: 700; cursor: pointer; font-size: 14px; text-transform: uppercase;
            border-radius: 30px; box-shadow: 0 4px 15px rgba(179, 0, 0, 0.4); transition: transform 0.2s;
        }
        #close-modal-btn:hover { transform: scale(1.05); background: #d40000; }

        #transition-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; display: flex; 
            justify-content: center; align-items: center; color: #ffcc00;
            font-size: 20px; font-weight: bold; opacity: 1; pointer-events: none;
            transition: opacity 0.8s; letter-spacing: 2px;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 8px; height: 8px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 15;
            box-shadow: 0 0 4px black; border: 1px solid black;
        }
    </style>
</head>
<body>

    <div id="transition-screen">ĐANG KHỞI TẠO BẢO TÀNG...</div>
    <div id="crosshair"></div>

    <div id="instruction-overlay">
        <b>HƯỚNG DẪN</b><br>
        Máy tính: W A S D<br>
        Điện Thoại: Nút ảo<br>
        <i>Chạm vào tranh để xem</i>
    </div>

    <div id="joystick-area">
        <div id="btn-up" class="joy-btn">▲</div>
        <div id="btn-left" class="joy-btn">◀</div>
        <div id="btn-right" class="joy-btn">▶</div>
        <div id="btn-down" class="joy-btn">▼</div>
    </div>

    <div id="zoom-modal">
        <div id="zoom-container">
            <img id="zoom-img" src="" class="zoom-content" style="display:none;">
            <video id="zoom-video" src="" controls class="zoom-content" style="display:none;"></video>
            <div id="zoom-caption"></div>
            <button id="close-modal-btn">Đóng lại</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CƠ SỞ DỮ LIỆU ---
        const database = {
            1: [ 
                { type: 'img', src: 'n1.jpg', desc: 'Sư đoàn 304 (Quân đoàn 2) nhận lẵng hoa của Chủ tịch nước Tôn Đức Thắng trước khi lên đường làm nhiệm vụ giúp nước bạn Campuchia năm 1978.' },
                { type: 'img', src: 'n2.jpg', desc: 'Pháo binh ta nhả đạn đánh quân Pôn-pốt năm 1979.' },
                { type: 'img', src: 'n3.jpg', desc: 'Nhân dân thị xã Long Xuyên tiễn người thân lên đường làm nhiệm vụ bảo vệ Tổ quốc năm 1978.' },
                { type: 'img', src: 'n4.jpg', desc: 'Lính Pol Pot dồn dân vào các khu trường học, chùa chiền rồi giết tập thể. Trong ảnh là xác người dân bên hông chùa Phi Lai.' },
                { type: 'img', src: 'n5.jpg', desc: 'Trên cánh đồng ở Ba Chúc, bên cạnh cây cầu sắc còn ngổn ngang xác người dân trong đêm thảm sát 14/04/1978.' },
                { type: 'img', src: 'n6.webp', desc: 'Trưa 7-1-1979, các lực lượng vũ trang cách mạng Campuchia cùng Quân tình nguyện Việt Nam tiến vào giải phóng Thủ đô Phnom Penh.' },
                { type: 'img', src: 'n7.jpg', desc: 'Bà mẹ Campuchia rót nước cho các chiến sĩ Quân tình nguyện Việt Nam.' },
                { type: 'img', src: 'n8.jpg', desc: 'Người dân Campuchia lánh nạn sang Việt Nam di chuyển trên Quốc lộ 22 (thuộc địa phận tỉnh Tây Ninh), do không thể sống nổi dưới chế độ diệt chủng Pol Pot-Ieng Sary.' },
                { type: 'img', src: 'n9.jpg', desc: 'Nhân dân Campuchia trong Lễ mừng chiến thắng 7/1/1979, được tổ chức ngày 25/1/1979 tại sân vận động Olympic ở thủ đô Phnom Penh.' },
                { type: 'img', src: 'n10.webp', desc: 'Bộ đội Việt Nam giúp nhân dân Campuchia bảo vệ đền Angkor Wat.' },
                { type: 'img', src: 'n11.webp', desc: 'Nhân dân tỉnh Ratanakiri (đông bắc Campuchia) đón chào bộ đội tình nguyện Việt Nam về giải phóng phum, sóc.' },
                { type: 'img', src: 'n12.jpg', desc: 'Bản đồ cuộc tấn công của quân Khơ me đỏ.' },
                { type: 'video', src: 'nvideo1.mp4', thumb: 'nvideo1_thumb.jpg', desc: 'Âm mưu và lược đồ quân Polpot tấn công Tây Nam.', color: 0xaa0000 },
                { type: 'video', src: 'nvideo2.mp4', thumb: 'nvideo2_thumb.jpg', desc: 'Lược đồ và kết hoạch phản công của quân Việt Nam.', color: 0xaa0000 },
            ],
            2: [ 
                { type: 'img', src: 'b1.png', desc: 'Báo quân đội nhân dân ra tuyên bố về hành động xâm lược của những người cầm quyền Trung Quốc.' },
                { type: 'img', src: 'b2.jpg', desc: '4 giờ 17 phút ngày 17/2/1979, giữa lúc nhân dân Hoàng Liên Sơn đang ngủ ngon thì bất thình lình hàng loạt đạn đại bác từ phía Bắc giội tới làm khắp biên giới bốc lửa ngùn ngụt. Hàng loạt quả đại bác thi nhau trút xuống thị xã Lào Cai, Cốc Lếu, nhằm thẳng các cơ quan, nhà máy…' },
                { type: 'img', src: 'b3.jpg', desc: 'Bức ảnh người chiến sĩ cầm súng B.41 đứng bên cột mốc biên giới số 0 ở Lạng Sơn đã trở thành biểu tượng của cuộc chiến bảo vệ biên giới phía Bắc 1979.' },
                { type: 'img', src: 'b4.jpg', desc: 'Nhà dân ở phố Nhị Thanh, khu Kỳ Lừa bị quân Trung Quốc xâm lược phá hủy trên báo Nhân Dân tháng 2/1979.' },
                { type: 'img', src: 'b5.jpg', desc: 'Hai đứa trẻ ở thị xã Cao Bằng ngược đường quốc lộ, băng rừng di tản về hướng Bắc Kạn, Thái Nguyên để tránh nạn.' },
                { type: 'img', src: 'b6.jpg', desc: 'Cầu sông Bằng (Cao Bằng) bị quân Trung Quốc đánh sập vào ngày tháng 2/1979.' },
                { type: 'img', src: 'b7.jpg', desc: 'Bộ đội ta hành quân Cao Bằng, vào ngày 25/2/1979 hình ảnh trên báo QĐND.' },
                { type: 'img', src: 'b8.jpg', desc: 'Quân chủ lực của Việt Nam trên trận địa phải đối đầu với quân Trung Quốc đông gấp 12 lần, được yểm trợ bởi hỏa lực mạnh, vì vậy bên cạnh những chiến sĩ chính quy còn có cả lực lượng dân quân.' },
                { type: 'img', src: 'b9.jpg', desc: 'Những chuyến hàng được vận chuyển lên biên giới phía Bắc.' },
                { type: 'img', src: 'b10.jpg', desc: 'Ngày 5/3/1979 Chủ tịch nước Tôn Đức Thắng ký sắc lệnh 29 - LCT ra lệnh tổng động viên trên cả nước. Hàng vạn thanh niên các tỉnh biên giới và toàn quốc nhanh chóng ghi danh nhập ngũ - Trong ảnh là thanh niên đăng ký lên đường bảo vệ tổ quốc.' },
                { type: 'img', src: 'b11.jpg', desc: 'Sẵn sàng hi sinh để bảo vệ từng tấc đất của tổ quốc -  ảnh tại mặt trận Vị Xuyên.' },
                { type: 'img', src: 'b12.jpg', desc: 'Bản tin chiến thắng đăng trên báo Nhân Dân.' },
                { type: 'video', src: 'bvideo1.mp4', thumb: 'bvideo1_thumb.jpg', desc: 'Bản tin thời sự của đài tiếng nói Việt Nam ngày 05/03/1979.', color: 0x00aa00 },
                { type: 'video', src: 'bvideo2.mp4', thumb: '1bvideo2_thumb.jpg', desc: 'Tư liệu về quân Trung Quốc tấn công.', color: 0x00aa00 },
            ],
            3: [
                { type: 'img', src: 'd1.webp', desc: 'Bản đồ xứ Quảng Nam trích trong An Nam Thiên Nam tứ chí lộ đồ thư thể hiện Vạn lý Trường Sa.' },
				{ type: 'img', src: 'd2.webp', desc: 'Bản A.95, chụp lại từ sách Một số tư liệu Hán Nôm về chủ quyền của Việt Nam đối với hai quần đảo Hoàng Sa, Trường Sa…, Viện Nghiên cứu Hán Nôm biên soạn-NXB KHXH, Hà Nội, 2014. Bản gốc lưu ở Thư viện Viện Nghiên cứu Hán Nôm – Đại Nam nhất thống toàn đồ.' },
                { type: 'img', src: 'd3.jpg', desc: 'Trạm thu phát sóng radio và trạm khí tượng do người Pháp xây dựng trên đảo Hoàng Sa (ảnh chụp năm 1940).' },
				{ type: 'img', src: 'd4.jpg', desc: 'Bia khẳng định chủ quyền Việt Nam do một đơn vị lính bảo an người Việt dựng trên đảo Hoàng Sa vào tháng 6-1938. Trên bia có khắc những dòng chữ bằng tiếng Pháp: Cộng hòa Pháp - Vương quốc An Nam - Quần đảo Hoàng Sa 1816 - Đảo Hoàng Sa 1938 - Ảnh tư liệu của UBND huyện Hoàng Sa.' },
				{ type: 'img', src: 'd5.jpg', desc: 'Bộ đội Hải quân giải phóng đảo Song Tử Tây ngày 14-4-1975.' },
                { type: 'img', src: 'd6.jpg', desc: 'Trận hải chiến Gạc Ma năm 1988.' },
				{ type: 'img', src: 'd7.jpg', desc: 'Hội nghị quốc tế về Luật Biển lần thứ ba thông qua Công ước UNCLOS mà Việt Nam ký tham gia năm 1982' },
                { type: 'img', src: 'd8.jpg', desc: 'Nhà giàn DK1 - Cột mốc chủ quyền vùng biển thiêng liêng của Tổ quốc – được mệnh danh là “mắt thần” trên biển Đông.' },
				{ type: 'img', src: 'd9.jpg', desc: 'Các đại biểu dự Hội nghị Quan chức cấp cao ASEAN-Trung Quốc lần thứ 20 về thực hiện Tuyên bố ứng xử của các bên ở Biển Đông.' },
                { type: 'video', src: 'dvideo1.mp4', thumb: 'dvideo1_thumb.jpg', desc: 'Ý thức bảo vệ chủ quyền biển đảo của dân tộc.', color: 0x0000aa },
                { type: 'video', src: 'dvideo2.mp4', thumb: 'dvideo2_thumb.jpg', desc: 'Đặc khu Trường Sa vững vàng tuyến đầu, giữ vững chủ quyền biển, đảo.', color: 0x0000aa }
            ]
        };

        const scene = new THREE.Scene();
        // ĐÃ XÓA SƯƠNG MÙ (FOG) ĐỂ KHÔNG BỊ MỜ ẢNH

        const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000);
        
        // --- CẤU HÌNH RENDERER (CỰC SÁNG) ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
        
        renderer.toneMapping = THREE.ReinhardToneMapping; 
        renderer.toneMappingExposure = 5.0; // Tăng sáng gấp 3 lần
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        controls.rotateSpeed = 0.4; controls.enablePan = false; controls.enableZoom = false;
        controls.minDistance = 0.1; controls.maxDistance = 0.2; 
        controls.maxPolarAngle = Math.PI / 1.5; controls.minPolarAngle = Math.PI / 2.8;

        let currentRoomGroup = new THREE.Group();
        scene.add(currentRoomGroup);
        
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let clickableObjects = []; 
        let portals = [];

        const moveState = { fwd: false, bwd: false, left: false, right: false };
        let currentSceneId = 0; 
        const moveSpeed = 8; 
        const PLAYER_RADIUS = 60; 

        // --- XỬ LÝ SỰ KIỆN PHÍM ---
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': case 'ArrowUp': moveState.fwd = true; break;
                case 'KeyS': case 'ArrowDown': moveState.bwd = true; break;
                case 'KeyA': case 'ArrowLeft': moveState.left = true; break;
                case 'KeyD': case 'ArrowRight': moveState.right = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': case 'ArrowUp': moveState.fwd = false; break;
                case 'KeyS': case 'ArrowDown': moveState.bwd = false; break;
                case 'KeyA': case 'ArrowLeft': moveState.left = false; break;
                case 'KeyD': case 'ArrowRight': moveState.right = false; break;
            }
        });

        const setupJoyBtn = (id, key) => {
            const btn = document.getElementById(id);
            const activeColor = '#ffcc00';
            const inactiveColor = 'rgba(255,255,255,0.15)';
            btn.addEventListener('pointerdown', (e) => { e.preventDefault(); moveState[key] = true; btn.style.background = activeColor; btn.style.color = 'black'; });
            btn.addEventListener('pointerup', (e) => { e.preventDefault(); moveState[key] = false; btn.style.background = inactiveColor; btn.style.color = 'white';});
            btn.addEventListener('pointerleave', (e) => { e.preventDefault(); moveState[key] = false; btn.style.background = inactiveColor; btn.style.color = 'white';});
        };
        setupJoyBtn('btn-up', 'fwd'); setupJoyBtn('btn-down', 'bwd');
        setupJoyBtn('btn-left', 'left'); setupJoyBtn('btn-right', 'right');

        function updateMovement() {
            if (portals.length > 0) {
                portals.forEach(portal => {
                    if (camera.position.distanceTo(portal.position) < 100) triggerTransition(portal.roomId);
                });
            }

            if (!moveState.fwd && !moveState.bwd && !moveState.left && !moveState.right) return;

            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); direction.y = 0; direction.normalize();
            const side = new THREE.Vector3(); side.crossVectors(camera.up, direction).normalize();
            const velocity = new THREE.Vector3();

            if (moveState.fwd) velocity.add(direction);
            if (moveState.bwd) velocity.sub(direction);
            if (moveState.left) velocity.add(side);
            if (moveState.right) velocity.sub(side);
            velocity.normalize().multiplyScalar(moveSpeed);

            const currentX = camera.position.x;
            const currentZ = camera.position.z;
            
            let nextX = currentX + velocity.x;
            let nextZ = currentZ + velocity.z;

            const roomSize = (currentSceneId === 0) ? 800 : 425; 
            const boundary = roomSize - PLAYER_RADIUS;

            if (nextX < -boundary) nextX = -boundary; else if (nextX > boundary) nextX = boundary;
            if (nextZ < -boundary) nextZ = -boundary; else if (nextZ > boundary) nextZ = boundary;

            const deltaX = nextX - currentX;
            const deltaZ = nextZ - currentZ;

            camera.position.x += deltaX;
            camera.position.z += deltaZ;
            
            controls.target.x += deltaX;
            controls.target.z += deltaZ;
        }

        let isTransitioning = false;
        function triggerTransition(roomId) {
            if(isTransitioning || roomId === currentSceneId) return;
            isTransitioning = true;
            moveState.fwd = false; moveState.bwd = false; moveState.left = false; moveState.right = false;
            
            const screen = document.getElementById('transition-screen');
            screen.style.opacity = 1; screen.innerText = "ĐANG DI CHUYỂN...";
            
            setTimeout(() => {
                if (roomId === 0) buildLobby();
                else goToRoom(roomId);
                
                setTimeout(() => { screen.style.opacity = 0; isTransitioning = false; }, 600);
            }, 600);
        }

        // --- TƯỜNG SÁNG HƠN ---
        function createWallTexture() {
            const canvas = document.createElement('canvas'); 
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Màu vàng kem sáng
            ctx.fillStyle = "#E8D8B0"; 
            ctx.fillRect(0, 0, 1024, 1024);

            // Noise nhẹ
            for (let i = 0; i < 60000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? "rgba(0,0,0,0.05)" : "rgba(255,255,255,0.2)";
                ctx.fillRect(Math.random()*1024, Math.random()*1024, 2, 2);
            }
            
            // Chân tường và trần
            ctx.fillStyle = "#5d4037"; ctx.fillRect(0, 1024 - 30, 1024, 30);
            ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, 1024, 20);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(2, 2); 
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // --- SÀN VẢI SÁNG HƠN ---
        function createFloorTexture() {
            const canvas = document.createElement('canvas'); 
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Xanh lá tươi hơn để bắt sáng
            ctx.fillStyle = "#2E5B38"; 
            ctx.fillRect(0, 0, 512, 512);

            // Noise vải
            for (let i = 0; i < 40000; i++) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.15})`;
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(8, 8); 
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        // --- LABEL MESH ---
        function createPortalLabelMesh(text, color, baseWidth) {
            const canvas = document.createElement('canvas');
            const w = 1024; canvas.width = w; 
            const ctx = canvas.getContext('2d');
            const fontSize = 80;
            ctx.font = "bold " + fontSize + "px 'Segoe UI', Arial";
            
            const words = text.split(' ');
            let lines = []; let currentLine = words[0];
            const maxLineWidth = w - 100; 

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxLineWidth) currentLine += " " + word;
                else { lines.push(currentLine); currentLine = word; }
            }
            lines.push(currentLine);
            
            const lineHeight = fontSize * 1.3;
            const realHeight = (lines.length * lineHeight) + 120; 
            canvas.height = realHeight; 
            
            ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; 
            ctx.beginPath();
            ctx.roundRect(10, 10, w - 20, realHeight - 20, 40);
            ctx.fill();
            
            ctx.strokeStyle = color; ctx.lineWidth = 15; ctx.stroke();

            ctx.font = "bold " + fontSize + "px 'Segoe UI', Arial"; 
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            const totalTextBlockHeight = lines.length * lineHeight;
            let currentY = (realHeight / 2) - (totalTextBlockHeight / 2) + (lineHeight / 2);

            for (let k = 0; k < lines.length; k++) {
                ctx.fillText(lines[k], w / 2, currentY + 10); 
                currentY += lineHeight;
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            const meshHeight = baseWidth * (realHeight / w);
            const material = new THREE.MeshBasicMaterial({ map: tex, transparent: true }); 
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(baseWidth, meshHeight), material);
            mesh.userData = { h: meshHeight };
            return mesh;
        }

        function createGuideBoardTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 576;
            const ctx = canvas.getContext('2d');
            
            const grd = ctx.createLinearGradient(0, 0, 1024, 576);
            grd.addColorStop(0, "#ffffff"); grd.addColorStop(1, "#e6e6e6");
            ctx.fillStyle = grd; ctx.fillRect(0,0,1024,576);
            
            ctx.strokeStyle = "#8B0000"; ctx.lineWidth = 20; ctx.strokeRect(10,10,1004,556);
            ctx.fillStyle = "#8B0000"; ctx.font = "bold 70px 'Segoe UI'"; ctx.textAlign = "center"; ctx.fillText("HƯỚNG DẪN THAM QUAN", 512, 100);
            
            ctx.fillStyle = "#222"; ctx.font = "32px 'Segoe UI'"; ctx.textAlign = "left";
            const lines = [
                "1. Di chuyển bằng phím W, A, S, D hoặc Nút ảo.",
                "2. Kéo chuột/vuốt màn hình để xoay góc nhìn.",
                "3. Bấm vào tranh/video để xem chi tiết.",
                "----------------------------------------",
                "• Phía bên phải: Phòng Đấu tranh bảo vệ biên giới phía Tây Nam.",
                "• Phía đằng sau: Phòng Đấu tranh bảo vệ biên giới phía Bắc.",
                "• Phía bên trái: Phòng Đấu tranh bảo vệ Biển Đông."
            ];
            let y = 180; 
            lines.forEach(line => { ctx.fillText(line, 80, y); y += 55; });
            
            const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; return tex;
        }

        function createCaptionMesh(text, width) {
            const w = 512; 
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // 1. Tăng độ đậm của chữ (700 -> bold)
            const fontSize = 22; 
            const font = "700 " + fontSize + "px 'Segoe UI'";
            tempCtx.font = font;

            const words = text.split(' ');
            let lines = []; let currentLine = words[0];
            const maxWidth = w - 40;

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = tempCtx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) currentLine += " " + word;
                else { lines.push(currentLine); currentLine = word; }
            }
            lines.push(currentLine);

            const lineHeight = fontSize * 1.4;
            const h = (lines.length * lineHeight) + 60; 

            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');

            // Nền trắng
            ctx.fillStyle = "rgba(255, 255, 255, 0.95)"; 
            ctx.fillRect(0, 0, w, h);
            // Viền đen
            ctx.strokeStyle = "#000000"; ctx.lineWidth = 6; ctx.strokeRect(3, 3, w-6, h-6);

            // 2. Chỉnh màu chữ thành ĐEN TUYỀN (#000000)
            ctx.font = font; 
            ctx.fillStyle = "#000000"; 
            ctx.textAlign = "center"; ctx.textBaseline = "middle";

            const startY = (h - (lines.length * lineHeight)) / 2 + (lineHeight / 2);
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], w / 2, startY + (i * lineHeight));
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.minFilter = THREE.LinearFilter;
            
            const meshHeight = width * (h / w); 
            
            // 3. Sử dụng MeshBasicMaterial: Loại này không chịu ảnh hưởng của ánh sáng/bóng đổ
            // Giúp chữ luôn hiển thị đúng màu đen thiết kế, không bị lóa hay bạc màu.
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(width, meshHeight), 
                new THREE.MeshBasicMaterial({ map: tex, transparent: true })
            );
            
            mesh.userData = { height: meshHeight }; 
            return mesh;
        }

        // --- HÀM XÂY DỰNG PHÒNG VỚI ÁNH SÁNG STUDIO (SIÊU SÁNG, KHÔNG MỜ) ---
        function buildRoomMesh(width, depth, height, isLobby) {
            // 1. CHẤT LIỆU
            const wallMat = new THREE.MeshStandardMaterial({ map: createWallTexture(), roughness: 0.5, side: THREE.DoubleSide });
            const floorMat = new THREE.MeshStandardMaterial({ map: createFloorTexture(), roughness: 0.8, metalness: 0.1 });
            // Trần nhà tự phát sáng mạnh
            const ceilMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 

            // 2. HÌNH HỌC
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(width, depth), floorMat);
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true; 
            currentRoomGroup.add(floor);

            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(width, depth), ceilMat);
            ceiling.rotation.x = Math.PI / 2; ceiling.position.y = height; 
            currentRoomGroup.add(ceiling);

            const createWall = (w, h, x, y, z, ry) => {
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), wallMat);
                mesh.position.set(x, y, z); mesh.rotation.y = ry;
                mesh.receiveShadow = true; mesh.castShadow = true;   
                currentRoomGroup.add(mesh);
            };
            createWall(width, height, 0, height/2, -depth/2, 0); 
            createWall(width, height, 0, height/2, depth/2, Math.PI); 
            createWall(depth, height, -width/2, height/2, 0, Math.PI/2); 
            createWall(depth, height, width/2, height/2, 0, -Math.PI/2);

            // 3. ÁNH SÁNG (LIGHTING) - FULL POWER
            
            // A. Ánh sáng nền (Ambient): Tăng cực mạnh
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            currentRoomGroup.add(ambientLight);

            // B. Đèn chính (Directional Light): Đèn mặt trời nhân tạo
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(0, 500, 0); 
            dirLight.target.position.set(0, 0, 0); 
            
            dirLight.castShadow = true;
            // Mở rộng vùng đổ bóng
            const shadowSize = 1000;
            dirLight.shadow.camera.left = -shadowSize;
            dirLight.shadow.camera.right = shadowSize;
            dirLight.shadow.camera.top = shadowSize;
            dirLight.shadow.camera.bottom = -shadowSize;
            dirLight.shadow.mapSize.width = 2048; 
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0005;
            
            currentRoomGroup.add(dirLight);
            currentRoomGroup.add(dirLight.target);

            // C. Đèn bổ trợ (Hemisphere)
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
            currentRoomGroup.add(hemiLight);
        }

        function createPortal(x, z, rotY, label, color, targetRoomId) {
            // Khung cổng
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(160, 240, 20), 
                new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 })
            );
            frame.position.set(x, 120, z); frame.rotation.y = rotY; 
            frame.castShadow = true; 
            frame.receiveShadow = true;
            currentRoomGroup.add(frame);

            const glowCanvas = document.createElement('canvas'); glowCanvas.width = 64; glowCanvas.height = 64;
            const ctx = glowCanvas.getContext('2d');
            const grd = ctx.createLinearGradient(0,0,0,64); grd.addColorStop(0, color); grd.addColorStop(1, "black");
            ctx.fillStyle = grd; ctx.fillRect(0,0,64,64);
            
            const portalMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(140, 220), 
                new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(glowCanvas) }) 
            );
            portalMesh.position.set(0, 0, 11); frame.add(portalMesh);

            const labelMesh = createPortalLabelMesh(label, color, 200);
            const labelY = 120 + (labelMesh.userData.h / 2) + 5;
            labelMesh.position.set(0, labelY, 0); 
            frame.add(labelMesh);

            const collisionPos = frame.position.clone();
            if(Math.abs(z) > Math.abs(x)) collisionPos.z += (z < 0 ? 50 : -50); else collisionPos.x += (x < 0 ? 50 : -50);
            portals.push({ position: collisionPos, roomId: targetRoomId });
        }

        window.buildLobby = function() {
            clearScene();
            currentSceneId = 0;
            scene.background = new THREE.Color(0x111111); 
            buildRoomMesh(1600, 1600, 500, true);

            const guideMat = new THREE.MeshStandardMaterial({ map: createGuideBoardTexture(), side: THREE.DoubleSide, roughness: 0.4 });
            const guideMesh = new THREE.Mesh(new THREE.PlaneGeometry(800, 450), guideMat);
            guideMesh.position.set(0, 250, 790); guideMesh.rotation.y = Math.PI; 
            guideMesh.castShadow = true;
            currentRoomGroup.add(guideMesh);

            createPortal(-750, 0, Math.PI/2, "1. Đấu tranh bảo vệ biên giới phía Tây Nam", "#b30000", 1);
            createPortal(0, -750, 0, "2. Đấu tranh bảo vệ biên giới phía Bắc", "#006600", 2);
            createPortal(750, 0, -Math.PI/2, "3. Đấu tranh bảo vệ Biển Đông	", "#0044cc", 3);

            camera.position.set(0, 160, -400); 
            controls.target.set(0, 160, 300); 
            controls.update();
        }

        window.goToRoom = function(id) {
            clearScene();
            currentSceneId = id;
            scene.background = new THREE.Color(0x111111);
            
            const roomSize = 850;
            const wallOffset = roomSize / 2;
            buildRoomMesh(roomSize, roomSize, 350, false);

            createPortal(300, -wallOffset + 10, 0, "⬅ QUAY VỀ SẢNH", "#555", 0);

            const data = database[id];
            
            data.forEach((item, i) => {
                let pos = { x:0, y:150, z:0 }; 
                let rotY = 0;
                const spacing = 190; 
                const spacing3 = 270;
                if (i < 4) { 
                    pos.x = -wallOffset; 
                    pos.z = -285 + (i * spacing); 
                    rotY = Math.PI / 2; 
                } 
                else if (i < 7) { 
                    let idx = i - 4; 
                    pos.z = -wallOffset; 
                    rotY = 0; 
                    pos.x = -250 + (idx * 160); 
                } 
                else if (i < 11) { 
                    let idx = i - 7; 
                    pos.x = wallOffset; 
                    pos.z = 285 - (idx * spacing); 
                    rotY = -Math.PI / 2; 
                } 
                else { 
                    let idx = i - 11; 
                    pos.z = wallOffset; 
                    pos.x = spacing3 - (idx * spacing3); 
                    rotY = Math.PI; 
                }

                const frameW = 140; const frameH = 100;
                const frameMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.4, metalness: 0.1 });
                const frame = new THREE.Mesh(new THREE.BoxGeometry(frameW+8, frameH+8, 4), frameMat);
                frame.position.set(pos.x, pos.y, pos.z); frame.rotation.y = rotY; frame.translateZ(4); 
                frame.castShadow = true; 
                frame.receiveShadow = true;
                currentRoomGroup.add(frame);

                let material;
                if (item.type === 'video') {
                    if (item.thumb) {
                        const thumbTex = new THREE.TextureLoader().load(item.thumb);
                        thumbTex.colorSpace = THREE.SRGBColorSpace;
                        material = new THREE.MeshStandardMaterial({ map: thumbTex, roughness: 0.2 });
                    } else {
                        material = new THREE.MeshStandardMaterial({ color: 0x222222 });
                    }
                } 
                else { 
                    const tex = new THREE.TextureLoader().load(item.src); 
                    tex.colorSpace = THREE.SRGBColorSpace; 
                    material = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.2 }); 
                }
                
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(frameW, frameH), material);
                mesh.position.copy(frame.position); mesh.rotation.copy(frame.rotation); mesh.translateZ(2.1); 
                mesh.userData = item; clickableObjects.push(mesh); currentRoomGroup.add(mesh);

                if(item.desc) {
                    const cap = createCaptionMesh(item.desc, frameW);
                    cap.position.copy(mesh.position); 
                    cap.rotation.copy(mesh.rotation); 
                    const capHeight = cap.userData.height || 40; 
                    cap.position.y -= (frameH/2 + capHeight/2 + 15); 
                    cap.translateZ(0.2); 
                    currentRoomGroup.add(cap);
                }
            });
            
            camera.position.set(-100, 150, 200); 
            controls.target.set(-100, 150, 199);
            controls.update();
        }

        function clearScene() {
            clickableObjects = []; portals = [];
            while(currentRoomGroup.children.length > 0){ 
                const obj = currentRoomGroup.children[0]; 
                currentRoomGroup.remove(obj); 
                if(obj.geometry) obj.geometry.dispose(); 
                if(obj.material) obj.material.dispose(); 
            }
        }

        window.openZoom = function(data) {
            const modal = document.getElementById('zoom-modal');
            const imgTag = document.getElementById('zoom-img'); const vidTag = document.getElementById('zoom-video'); const captionTag = document.getElementById('zoom-caption');
            modal.style.display = 'flex'; captionTag.innerText = data.desc;
            if(data.type === 'video') { imgTag.style.display = 'none'; vidTag.style.display = 'block'; vidTag.src = data.src; vidTag.play(); } 
            else { vidTag.style.display = 'none'; vidTag.pause(); imgTag.style.display = 'block'; imgTag.src = data.src; }
        }
        document.getElementById('close-modal-btn').addEventListener('click', (e) => { document.getElementById('zoom-modal').style.display = 'none'; document.getElementById('zoom-video').pause(); e.stopPropagation(); });
        document.getElementById('zoom-container').addEventListener('click', (e) => { e.stopPropagation(); });

        let isDragging = false; let pointerDownTime = 0;
        renderer.domElement.addEventListener('pointerdown', () => { isDragging = false; pointerDownTime = Date.now(); });
        renderer.domElement.addEventListener('pointermove', () => { isDragging = true; });
        renderer.domElement.addEventListener('pointerup', (event) => {
            if (isDragging && (Date.now() - pointerDownTime > 250)) return; 
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(clickableObjects, false);
            if (intersects.length > 0) openZoom(intersects[0].object.userData);
        });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        setTimeout(() => { document.getElementById('transition-screen').style.opacity = 0; }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            updateMovement();
            controls.update();
            renderer.render(scene, camera);
        }

        buildLobby(); animate();
    </script>
</body>
</html>